# Flask #4: Формирование ответа сервера, декораторы перехвата запроса

from flask import Flask, render_template, make_response, redirect, url_for

app = Flask(__name__)

# способами формирования ответа сервера во Flask. Что это вообще такое? Когда пользователь запрашивает ту или иную страницу, то браузер получает данные в виде:
# <заголовок ответа><HTML-документ>
# В этом заголовке находится «служебная» информация, сообщающая браузеру, как интерпретировать принятые данные. Например, там указывается код ответа
# 200 – все нормально;
# 404 – страница не найдена;
# 301 – выполнено перенаправление с другого URL;
# 401 – доступ запрещен
# и так далее. Кроме того, в заголовке в параметре content-type прописывается тип данных:
# text/html
# text/plain
# image/jpeg
# audio/mp4
# multipart/form-data
# Все это имеет большое значение при разработке сайтов. На этом занятии мы как раз и поговорим о работе с этим заголовком.
# Обратите внимание, заголовок ответа сервера не имеет ничего общего с заголовком HTML-страницы, то есть, с содержимым тега
# <head></head>
# это разные вещи. Итак, во Flask заголовок в ответ на запрос можно формировать тремя способами:
# В обработчике возвратить строку, тогда автоматически ответом будет content-type=text/html и код 200.
# Сформировать ответ с помощью функции make_response()
# Возвратить кортеж формата: (response, status, headers) или (response, headers)
# Первый способ используется наиболее часто, например, вот в такой упрощенной программе:

# Функция make_response
# Однако, если мы хотим самостоятельно определить некоторые параметры заголовка,
# то можно воспользоваться специальной функцией
# res_obj = make_response(res_body, status_code=200)
# которая возвращает ссылку на объект ответа. Здесь:
# res_body – передаваемое содержимое (контент);
# status_code – код ответа сервера (по умолчанию 200).
# Функция make_response() отправляет ссылку на объект запроса res_obj

# Предположим, что мы хотим отправить браузеру страницу в виде обычного текста render_template('index.html', menu=menu, posts=[]).
# Для этого создадим следующий ответ:
# content - это многострочный текст, где на его основе создается объект запроса make_response(), импортируем функцию
# используя ссылку res на объект запроса headers(по сути словарь) и говорим, что 'Content-Type' будет принимать объект 'text/plain'
# res.headers['Server'] = 'flasksite' - данные будут сформированы на сервере нашего приложения flasksite

# создаем запрос на основе данного изображения
# res = make_response(img)
# загружаем изображение из подкаталога static/images и отдаем его браузеру, указывая, что принятые данные следует представлять в виде png изображения
# Content-Type прописывается, сто данные, которые будут воспринимать как изображение в формате png

# сообщим дополнительно браузеру код ответа сервера Ошибка сервера - "GET / HTTP/1.1" 500

# Создание ответа с помощью кортежей
# Последний способ создать ответ – использовать кортежи в одном из следующих форматов:
# (response, status, headers)
# (response, headers)
# (response, status)
# response — строка, представляющая собой тело ответа, status — код состояния HTTP,
# который может быть указан в виде целого числа или строки,
# headers — словарь со значениями заголовков
# воспользуемся декоратором для обработки ошибок errorhandler
# 404 - страница не найдена

# пропишем в index - кортеж, который состоит из 3-х компонент(строка ответа,код ответа {словарь заголовок : значение})
# заголовок будет восприниматься как обычный текст <h1>Main Page</h1>
# таким образом можноф ормировать ответ сервера во Flask

# Создание 301 и 302 редиректов
# Очень часто при развитии сайта некоторые его страницы переносятся на другой URL-адрес.
# И, чтобы не потерять позиции этих страниц в поисковой выдаче, поисковым системам нужно явно указать,
# что страница перемещена либо временно, либо постоянно на новый URL. Это делается с помощью перенаправления с кодами:
# 301 – страница перемещена на другой постоянный URL-адрес;
# 302 – страница перемещена временно на другой URL-адрес.
# Чтобы во Flask выполнить перенаправление с прежнего URL на новый, можно использовать функцию
# redirect(location, status)
# о которой мы уже говорили. В данном случае ее можно применить так:

# Перехват запросов - декораторы
# В веб-приложениях часто нужно исполнить определенный код до или после запроса.
# И, как мы видели, в частности, это используется для установления соединения с БД.
# Нам в каждой функции представления приходилось осуществлять подключение к БД,
# следующим образом:
# DRY – Don’t Repeat Yourself
# чтобы вынести за скобки этот общий код,
# db = get_db()               # функции
# dbase = FDataBase(db)       # подключения к БД
# можно воспользоваться специальными декораторами для перехвата запросов:
# before_first_request – выполняет функцию до обработки первого запроса;
# before_request – выполняет функцию до обработки текущего запроса;
# after_request – выполняет функцию после обработки запроса (такая функция не вызывается при возникновении исключений в обработчике запросов);
# teardown_request (похож на after_request) – вызванная функция всегда будет выполняться вне зависимости от того, возвращает ли обработчик исключение (ошибку) или нет.
# первые две функции только выполняют определенные действия, не возвращая никакого значения,
# а последние две – принимают объект response и возвращают его. Запустим эту программу и при переходе на главную страницу сайта увидим следующие строки в консоли приложения:
# в декораторе можно прописать полезный код, например подключение к БД
# в декораторе teardown_request() можно сделать разрыв соединения с БД после обработки запроса

menu = [{"title": "Главная", "url": "/"},
        {"title": "Добавить статью", "url": "/add_post"}]


@app.route("/")
def index():
    # return render_template('index.html', menu=menu, posts=[])

    # content = render_template('index.html', menu=menu, posts=[])
    # res = make_response(content)
    # res.headers['Content-Type'] = 'text/plain'
    # res.headers['Server'] = 'flasksite'
    # return res

    # img = None
    # with app.open_resource(app.root_path + "/static/images/ava.png", mode="rb") as f:
    #     img = f.read()
    # if img is None:
    #     return "None image"
    # res = make_response(img)
    # res.headers['Content-Type'] = 'image/png'
    # return res

    # res = make_response("<h1>Ошибка сервера</h1>", 500)
    # return res

    return "<h1>Main Page</h1>", 200, {'Content-Type': 'text/plain'}

@app.errorhandler(404)
def pageNot(error):
    return ("Страница не найдена", 404)


@app.route('/transfer')
def transfer():
    return redirect(url_for('index'), 301)


@app.before_first_request
def before_first_request():
    print("before_first_request() called")


@app.before_request
def before_request():
    print("before_request() called")


@app.after_request
def after_request(response):
    print("after_request() called")
    return response


@app.teardown_request
def teardown_request(response):
    print("teardown_request() called")
    return response

# webserver start
if __name__ == "__main__":
    app.run(debug=True)

# Test
# http://127.0.0.1:5000/             :    GET / HTTP/1.1" 200
# http://127.0.0.1:5000/uncorrecturl :    GET /uncorrecturl HTTP/1.1" 404
# http://127.0.0.1:5000/transfer     :    GET /transfer HTTP/1.1" 301