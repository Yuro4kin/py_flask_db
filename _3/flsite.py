# Flask #9: Добавление и отображение статей из БД
#           В БД сохраняется вся изменяемая информация, которая потом используется при формировании ответов на запросы пользователей
import sqlite3
import os
from flask import Flask, render_template, request, flash, session, redirect, url_for, abort, g
from FDataBase import FDataBase


# 2. переходим в БД SQLite - наполняем таблицу mainmenu
#    прочитаем записи из таблицы и отобразим на странице сайта

# 1. выполним конфигурацию текущего WSGI DB приложения. Правило Flask - все переменные заглавными буквами относятся к конфигурационной информации
# DATABASE   - путь к нашему файлу
# DEBUG      - устанавливает режим отладки нашего приложения, True значит включено
# SECRET_KEY -
DATABASE = '/tmp/flsite.db'
DEBUG = True
SECRET_KEY = 'fdgfh78@#5?>gfhf89dx,v06k'

app = Flask(__name__)

# 1. Загружаем нашу конфигурацию DATABASE, DEBUG, SECRET_KEY из нашего приложения с помощью метода
#    from_object(), __name__ - это мы указываем из какого модуля мы будем загружать нашу конфигурацию
#    __name__ - это директива, которая указывает на этот текущий модуль, на основе переменных формируем начальную конфигурацию
#    теперь приложение создано, переопределим путь к БД
#    root_path - ссылается на текущий каталог данного приложения, этому приложению добавим файл 'flsite.db'
#    теперь сформирован полный путь к нашей БД
app.config.from_object(__name__)
app.config.update(dict(DATABASE=os.path.join(app.root_path, 'flsite.db')))
# 1. Концепция создания БД --> создание таблиц без запуска web server --> затем обработчики запросов обращаются к созданным табблицам БД
#    и затем записывают и считывают из них информацию
#    Создадим общую функцию для установления соединения с БД - вызываем sqlite3 и методу connect передаем путь где расположена наша БД
#    т.е. берем ее из конфигурации нашего приложения. row_factory - чтоб записи из БД были в виде словаря, а не в виде кортежей, словарь удобно использовать в шаблонах
#    функция возвращает установленное соединение conn
def connect_db():
    conn = sqlite3.connect(app.config['DATABASE'])
    conn.row_factory = sqlite3.Row
    return conn
# 1. объявим функцию, которая создаст БД, без запуска web server, просто создаем БД с набором таблиц
#    connect_db() - вызываем функцию, которую выше объявили
#    with...      - вызываем менеджер контекста, чтоб прочитать файл из рабочего каталога приложения
#    sq_db.sql    - файл в котором написан набор скриптов для создания таблиц сайта, mode='r' - открыт файл на чтение
#    db.cursor()  - берем соединение из БД, через класс cursor выполняем метод executescript
#    executescript() - метод запускает выполнение тех скриптов SQL, которые были прочитаны из файла
#    f.read()     - читаем скрипты и соответственно выполняем
#    db.commit()  -  после того как все сделано, записываем изменения в БД
#    db.close()   - сохраняем таблицу и закрываем соединение с БД
def create_db():
    """Вспомогательная функция для создания таблиц БД"""
    db = connect_db()
    with app.open_resource('sq_db.sql', mode='r') as f:
        db.cursor().executescript(f.read())
    db.commit()
    db.close()

# 1. server - Python console
# create_db() - незапуская  сервер можем вызвать ф-цию create_db() - на реальном сервере так не работают
# переходим для работы в python console, где мы можем выполнять любые команды python
# на сервере можно делать тоже самое
# >>> from flask_1_create_DB_connect_sql import create_db
#     из нашего файла импортируем ф-цию create_db


# 1. get_db() - функция соединения с БД
# когда приходит запрос, то создается контекст приложения, в этом контексте есть глобальная переменная g,
# в которую мы можем записать любую пользовательскую информацию. Запишем в g - установление соединения с БД
# if - проверяем существует ли у этого объекта g свойство db, если существует это св-во, значит соединение с БД было уже установлено
# если есть, то возвращаем функцией, return g.link_db
# если впервые устанавливаем соединение вызываем функцию connect_db(), которая прописана выше устанавливает соединение с нашей БД
def get_db():
    '''Соединение с БД, если оно еще не установлено'''
    if not hasattr(g, 'link_db'):
        g.link_db = connect_db()
    return g.link_db



# 1. разорвать соединение с БД
# используем декоратор teardown_appcontext - срабатывает, когда происходит уничтожение контекста приложения, обычно происходит в момент окончания обработки запроса
# декоратор является обработчиком для завершения работы с БД
# error - если будут какие-то ошибки, то в параметре будут отображаться
# if - проверяем, если в контексте нашего глобального приложения g существует св-во link_db, значит соединение с БД было установлено
# .close() - закроем соединение с БД обратився к соединению g.link_db
@app.teardown_appcontext
def close_db(error):
    '''Закрываем соединение с БД, если оно было установлено'''
    if hasattr(g, 'link_db'):
        g.link_db.close()


# 2. В обработчике главной страницы создадим специальный класс FDataBase(db), создаем экземпляр этого класса dbase
#    через экземпляр dbase вызываем меню getMenu(), getMenu() - возвращает коллекцию из словарей, можно использовать ссылку на эту коллекцию
#    в шаблоне формируется indexdb.html меню нашей страницы
#    FDataBase(db) - это класс, который описан в отдельном файле FDataBase.py
#    menu - формируем ссылку на коллекцию из функции getMenu() файла FDataBase.py
#    затем в шаблоне indexdb.html --> basedb.html у нас есть коллекция menu с перебором цикла for  - {% for m in menu -%}
#    также есть сформированный url ссылки и заголовок title {{m.url}}">{{m.title}}
#    таким образом мы берем коллекцию из нашей таблицы и отображаем в шаблоне
#    нужно добавить обработчик, т.к. страница http://127.0.0.1:5000/add_post  ERROR
#    нужно реализовать функционал добавления статей post в БД, для этого нужна таблица
#    перейдем в python console, запусти функцию create_db() незапуская сервер или запустим файл flask_1create)DB
#    далее в файле .db проверим созданные поля таблицы posts
@app.route("/")
def index():
    db = get_db()
    dbase = FDataBase(db)
    return render_template('index.html', menu = dbase.getMenu(), posts=dbase.getPostsAnonce())


# 2. добавим обработчик адреса /add_post, где будет отображаться форма с добавлением статьи
#    будем принимать запросы  POST GET
#    addPost() - функция представления данного url адреса
#    if request.method == "POST": - если данные от формы пришли по POST запросу
#    > 4  - заголовок статьи должен быть более 4 символов  -  пример как можно делать проверку
#    > 10 - содержимое статьи более 10 символов            -  пример как можно делать проверку
#    'name' и 'post' прописываются из формы
#    if - если проверка прошла, то добавляется post в нашу БД, для этого используем класс FDataBase(db) и вызываем в нем метод addPost()
#    addPost() - в этот метод добавляется заголовок name и название статьи post
#    if error - если при добавлении ошибки, то формируется сообщение
#    else - иначе категория добавлено успешно
#    render_template - на выходе добавляется шаблон add_post.html, который возвращается обработчиком
#    пропишем метод addPost() в классе, файл FDataBase()
#    - добавим в обработчик add_post адрес url еще одним аргументом в переменную res, и укажем url который возьмем из этой формы
#    - также модифицируем, поменяем метод addPost() в файле FDataBase.py
@app.route("/add_post", methods=["POST", "GET"])
def addPost():
    db = get_db()
    dbase = FDataBase(db)

    if request.method == "POST":
        if len(request.form['name']) > 4 and len(request.form['post']) > 10:
            res = dbase.addPost(request.form['name'], request.form['post'], request.form['url'])
            if not res:
                flash('ERROR  of add post', category='error')
            else:
                flash('Post added successfully', category='success')
        else:
            flash('ERROR  of add post', category='error')

    return render_template('addpost.html', menu=dbase.getMenu(), title="Add post")


# отобразим добавленную статью из post на страницах нашего сайта
# обработчик для отображения статьи по url адресу "/post/<int:id_post>"
# функция showPost() будет принимать параметр id_post
# db - соединяемся с БД
# FDataBase(db) - в этом классе у нас будет еще один метод getPost(), т.е. мы будем из БД брать статью по этому id - id_post
# if - отображаем статью, если стаья не получена из БД - ошибка 404, если все прошло возвращаем шаблон post.html
# добавим getPost() - метод который будет брать данные из БД в файл FDataBase.py
# вместо int:id_post пропишем alias для отображения url на странице, также изменим метод getPost в файле FDataBase.py
@app.route("/post/<alias>")
def showPost(alias):
    db = get_db()
    dbase = FDataBase(db)
    title, post = dbase.getPost(alias)
    if not title:
        abort(404)

    return render_template('post.html', menu=dbase.getMenu(), title=title, post=post)



# отобразим список добавленных статей на главной странице сайта, которые добавили в нашу таблицу posts
# изменим обработчик главной страницы @app.route("/"), добавим коллекцию posts=dbase... ('index.html', menu = dbase.getMenu(), posts=dbase.getPostsAnonce())
# коллекцию posts=dbase получим из класса FDataBase() методом .getPostAnonce(), который пропишем в файле FdataBase.py




# webserver start
if __name__ == "__main__":
    app.run(debug=True)




# Test
# http://127.0.0.1:5000/add_post - 200 -  "GET /add_post HTTP/1.1"
#                      /add_post - 200 =       /add_post
